{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sl240\slmult1\qc\b\f0\fs22\lang9 Scope, Duration, and Linkage \par
6.1 Compound statements (blocks)\par
\par

\pard\sl240\slmult1 - \b0 A compound statement (also called a block, or block statement) is a group of zero or more statements that is treated by the compiler as if it were a single statement.\par
- Blocks begin with a \{ symbol, end with a \} symbol, with the statements to be executed being placed in between. Blocks can be used anywhere a single statement is allowed. No semicolon is needed at the end of a block. \par
- Although functions can\rquote t be nested inside other functions, blocks can be nested inside other blocks\par
- It is even possible to put blocks inside of blocks inside of blocks\par
- The nesting level (also called the nesting depth) of a function is the maximum number of nested blocks you can be inside at any point in the function (including the outer block)\par
- Keep the nesting level of your functions to 3 or less. If your function has a need for more nested levels, consider refactoring your function into sub-functions.\par
\b\par

\pard\sl240\slmult1\qc\par
6.2 User-defined namespaces and the scope resolution operator\par
\par

\pard\sl240\slmult1 - \b0 C++ allows us to define our own namespaces via the namespace keyword\par
-  Namespaces that you create for your own declarations are called user-defined namespaces. Namespaces provided by C++ (such as the global namespace) or by libraries (such as namespace std) are not considered user-defined namespaces.\par
- The best way to tell the compiler to look in a particular namespace for an identifier is to use the scope resolution operator (::). The scope resolution operator tells the compiler that the identifier specified by the right-hand operand should be looked for in the scope of the left-hand operand.\par
- If an identifier inside a namespace is used and no scope resolution is provided, the compiler will first try to find a matching declaration in that same namespace. If no matching identifier is found, the compiler will then check each containing namespace in sequence to see if a match is found, with the global namespace being checked last.\par
- It\rquote s legal to declare namespace blocks in multiple locations (either across multiple files, or multiple places within the same file). All declarations within the namespace are considered part of the namespace.\par
- Namespace aliases: Because typing the fully qualified name of a variable or function inside a nested namespace can be painful, C++ allows you to create namespace aliases, which allow us to temporarily shorten a long sequence of namespaces into something shorter. \par
\par
namespace active = foo::goo;\b\par

\pard\sl240\slmult1\qc\par
6.3 Local variables\par
\par

\pard\sl240\slmult1 - \b0 Local variables have block scope, which means they are in scope from their point of definition to the end of the block they are defined within.\par
- A variable\rquote s storage duration (usually just called duration) determines what rules govern when and how a variable will be created and destroyed. In most cases, a variable\rquote s storage duration directly determines its lifetime.\par
- For example, local variables have automatic storage duration, which means they are created at the point of definition and destroyed at the end of the block they are defined in.\par
- Identifiers have another property named linkage. An identifier\rquote s linkage determines whether other declarations of that name refer to the same object or not.\par
- Local variables have no linkage, which means that each declaration refers to a unique object. \par
- Define variables in the most limited existing scope. Avoid creating new blocks whose only purpose is to limit the scope of variables.\par
\b\par

\pard\sl240\slmult1\qc\par
6.4 Introduction to global variables\par

\pard\sl240\slmult1\par
- \b0 In C++, variables can also be declared outside of a function. Such variables are called global variables.\b\par
- \b0 Consider using a \ldblquote g\rdblquote  or \ldblquote g_\rdblquote  prefix for global variables to help differentiate them from local variables.\par
- Global variables have file scope (also informally called global scope or global namespace scope), which means they are visible from the point of declaration until the end of the file in which they are declared\par
- Once declared, a global variable can be used anywhere in the file from that point onward! In the above example, global variable g_x is used in both functions doSomething() and main().\par
- Global variables are created when the program starts, and destroyed when it ends. This is called static duration. Variables with static duration are sometimes called static variables.\par
- Unlike local variables, which are uninitialized by default, static variables are zero-initialized by default.\par
\par

\pard\sl240\slmult1\qc\b\par
6.5 Variable shadowing (name hiding)\par
\par

\pard\sl240\slmult1 - \b0 Each block defines its own scope region. So what happens when we have a variable inside a nested block that has the same name as a variable in an outer block? When this happens, the nested variable \ldblquote hides\rdblquote  the outer variable in areas where they are both in scope. This is called name hiding or shadowing.\par
- When inside the nested block, there\rquote s no way to directly access the shadowed variable from the outer block.\par
- Similar to how variables in a nested block can shadow variables in an outer block, local variables with the same name as a global variable will shadow the global variable wherever the local variable is in scope\par
- However, because global variables are part of the global namespace, we can use the scope operator (::) with no prefix to tell the compiler we mean the global variable instead of the local variable.\par
- Shadowing of local variables should generally be avoided, as it can lead to inadvertent errors where the wrong variable is used or modified. Some compilers will issue a warning when a variable is shadowed.\b\par

\pard\sl240\slmult1\qc\par
\par
6.6 Internal linkage\par
\par

\pard\sl240\slmult1 - \b0 Global variable and functions identifiers can have either internal linkage or external linkage\par
- An identifier with internal linkage can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.\par
- Global variables with internal linkage are sometimes called internal variables.\par
- To make a non-constant global variable internal, we use the static keyword.\par
- Const and constexpr global variables have internal linkage by default\par
- The use of the static keyword above is an example of a storage class specifier, which sets both the name\rquote s linkage and its storage duration (but not its scope). The most commonly used storage class specifiers are static, extern, and mutable. The term storage class specifier is mostly used in technical documentations.\par
- Functions default to external linkage (which we\rquote ll cover in the next lesson), but can be set to internal linkage via the static keyword\par
\b\par

\pard\sl240\slmult1\qc\par
6.7 External linkage and variable forward declarations\par

\pard\sl240\slmult1 - \b0 An identifier with external linkage can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration). In this sense, identifiers with external linkage are truly \ldblquote global\rdblquote  in that they can be used anywhere in your program!\par
- Functions have external linkage by default.\par
- Global variables with external linkage are sometimes called external variables. To make a global variable external (and thus accessible by other files), we can use the extern keyword.\par
- To actually use an external global variable that has been defined in another file, you also must place a forward declaration for the global variable in any other files wishing to use the variable. For variables, creating a forward declaration is also done via the extern keyword (with no initialization value).\par
- Warning: If you want to define an uninitialized non-const global variable, do not use the extern keyword, otherwise C++ will think you\rquote re trying to make a forward declaration for the variable.\par
- Warning: Although constexpr variables can be given external linkage via the extern keyword, they can not be forward declared, so there is no value in giving them external linkage. This is because the compiler needs to know the value of the constexpr variable (at compile time). If that value is defined in some other file, the compiler has no visibility on what value was defined in that other file.\par
- \b\par

\pard\sl240\slmult1\qc\par
 6.8 Why (non-const) global variables are evil\par

\pard\sl240\slmult1 - \b0 Many developers believe non-const global variables should be avoided completely!\par
- Global variables (non-const) can change and can cause issues\par
- Dynamic initialization of global variables causes a lot of problems in C++. Avoid dynamic initialization whenever possible.\par
- Prefix all non-namespaced global variables with \ldblquote g\rdblquote  or \ldblquote g_\rdblquote , or better yet, put them in a namespace \par
- Instead of allowing direct access to the global variable, it\rquote s a better practice to \ldblquote encapsulate\rdblquote  the variable. Make sure the variable can only be accessed from within the file it\rquote s declared in, e.g. by making the variable static or const, then provide external global \ldblquote access functions\rdblquote  to work with the variable.\par
- When writing an otherwise standalone function that uses the global variable, don\rquote t use the variable directly in your function body. Pass it in as an argument instead. That way, if your function ever needs to use a different value for some circumstance, you can simply vary the argument. This helps maintain modularity.\par
- Joke: What\rquote s the best naming prefix for a global variable? Answer: //\b\par

\pard\sl240\slmult1\qc\par
6.9 Sharing global constants across multiple files (using inline variables)\par

\pard\sl240\slmult1\b0\par
- Prior to C++17, the following is the easiest and most common solution to access global constants:\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li720\sl240\slmult1 Create a header file to hold these constants\par
{\pntext\f0 2.\tab}Inside this header file, define a namespace (discussed in lesson 6.2 -- User-defined namespaces and the scope resolution operator)\par
{\pntext\f0 3.\tab}Add all your constants inside the namespace (make sure they\rquote re constexpr)\par
{\pntext\f0 4.\tab}#include the header file wherever you need it\par

\pard\sl240\slmult1 - Issues with above method:\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li720\sl240\slmult1 Because of the implementation, the constants are copied into every file that uses them. Most of the time, the compiler can optimize away to reduce memory, but not always.\par
{\pntext\f0 2.\tab}Changing a single constant value would require recompiling every file that includes the constants header, which can lead to lengthy rebuild times for larger projects.\par
{\pntext\f0 3.\tab}If the constants are large in size and can\rquote t be optimized away, this can use a lot of memory.\par

\pard\sl240\slmult1 - We can avoid the above by using an external variable by defining it in a .cpp file instead of .h\par
- Now the symbolic constants will get instantiated only once (in constants.cpp) instead of in each code file where constants.h is #included, and all uses of these constants will be linked to the version instantiated in constants.cpp.\par
- Any changes made to constants.cpp will require recompiling only constants.cpp.\par
- But, these constants are now no longer compile time constants. They are runtime constants. In order for variables to be usable in compile-time contexts, such as array sizes, the compiler has to see the variable\rquote s definition (not just a forward declaration).\par
- C++17 introduced a new concept called inline variables. In C++, the term inline has evolved to mean \ldblquote multiple definitions are allowed\rdblquote . Thus, an inline variable is one that is allowed to be defined in multiple files without violating the one definition rule. \par
- Inline global variables have external linkage by default.\par
- The linker will consolidate all inline definitions of a variable into a single variable definition (thus meeting the one definition rule). This allows us to define variables in a header file and have them treated as if there was only one definition in a .cpp file somewhere.\par
- Let\rquote s say you have a normal constant that you\rquote re #including into 10 code files. Without inline, you get 10 definitions. With inline, the compiler picks 1 definition to be the canonical definition, so you only get 1 definition. This means you save 9 constants worth of memory. \par
- These variables will also retain their constexpr-ness in all files in which they are included, so they can be used anywhere a constexpr value is required. \par
- Constexpr values can also be more highly optimized by the compiler than runtime-const (or non-const) variables.\par
- All definitions of the inline variable must be identical (otherwise, undefined behavior will result).\par
- The inline variable definition (not a forward declaration) must be present in any file that uses the variable.\par
- If you need global constants and your compiler is C++17 capable, prefer defining inline constexpr global variables in a header file.\par
\par

\pard\sl240\slmult1\qc\b\par
6.10 Static local variables\par
\par

\pard\sl240\slmult1 - \b0 Local variables have automatic duration by default, which means they are created at the point of definition, and destroyed when the block is exited.\par
- Using the static keyword on a local variable changes its duration from automatic duration to static duration. This means the variable is now created at the start of the program, and destroyed at the end of the program (just like a global variable). As a result, the static variable will retain its value even after it goes out of scope!\par
- Initialize your static local variables. Static local variables are only initialized the first time the code is executed, not on subsequent calls.\par
- One good use for a const static local variable is when you have a function that needs to use a const value, but creating or initializing the object is expensive (e.g. you need to read the value from a database). If you used a normal local variable, the variable would be created and initialized every time the function was executed. With a const static local variable, you can create and initialize the expensive object once, and then reuse it whenever the function is called.'\par
- Avoid static local variables unless the variable never needs to be reset\par
\par
\b\par

\pard\sl240\slmult1\qc\par
6.11 Scope, duration, and linkage summary\par

\pard\sl240\slmult1\b0\par
Scope:\par
- An identifier\rquote s scope determines where the identifier can be accessed within the source code.\par
- Variables with block (local) scope can only be accessed within the block in which they are declared (including nested blocks). This includes:\par

\pard\li720\sl240\slmult1 - Local variables\par
- Function parameters\par
- User-defined type definitions (such as enums and classes) declared inside a block\par

\pard\sl240\slmult1 - Variables and functions with file (global) scope can be accessed from the point of declaration until the end of the file. This includes:\par

\pard\li720\sl240\slmult1 - Global variables\par
- Functions\par
- User-defined type definitions (such as enums and classes) declared inside a namespace or in the global scope\par

\pard\sl240\slmult1\par
Duration: \par
- A variable\rquote s duration determines when it is created and destroyed.\par
- Variables with automatic duration are created at the point of definition, and destroyed when the block they are part of is exited. This includes:\par

\pard\li720\sl240\slmult1 - Local variables\par
- Function parameters\par

\pard\sl240\slmult1 - Variables with static duration are created when the program begins and destroyed when the program ends. This includes:\par

\pard\li720\sl240\slmult1 - Global variables\par
- Static local variables\par

\pard\sl240\slmult1 - Variables with dynamic duration are created and destroyed by programmer request. This includes:\par
\tab - Dynamically allocated variables\par
\par
Linkage:\par
- An identifier\rquote s linkage determines whether multiple declarations of an identifier refer to the same identifier or not.\par
- An identifier with no linkage means the identifier only refers to itself. This includes:\par

\pard\li720\sl240\slmult1 - Local variables\par

\pard\sl240\slmult1\tab - User-defined type definitions (such as enums and classes) declared inside a block\par
- An identifier with internal linkage can be accessed anywhere within the file it is declared. This includes:\par

\pard\li720\sl240\slmult1  - Static global variables (initialized or uninitialized)\par
 - Static functions\par
 - Const global variables\par
 - Functions declared inside an unnamed namespace\par
 - User-defined type definitions (such as enums and classes) declared inside an unnamed namespace\par

\pard\sl240\slmult1  - An identifier with external linkage can be accessed anywhere within the file it is declared, or other files (via a forward declaration). This includes:\par

\pard\li720\sl240\slmult1 - Functions\par
- Non-const global variables (initialized or uninitialized)\par
- Extern const global variables\par
- Inline const global variables\par
- User-defined type definitions (such as enums and classes) declared inside a namespace or in the global scope\par

\pard\sl240\slmult1 - Identifiers with external linkage will generally cause a duplicate definition linker error if the definitions are compiled into more than one .cpp file (due to violating the one-definition rule). \par
- There are some exceptions to this rule (for types, templates, and inline functions and variables)\par
- Also note that functions have external linkage by default. They can be made internal by using the static keyword.\par
\par
Variable scope, duration, and linkage\par
- Because variables have scope, duration, and linkage, let\rquote s summarize in a chart:\par
\par
\b\fs20 Type\tab\tab\tab\tab\tab Example\tab\tab\tab Scope\tab Duration\tab Linkage\tab\tab Notes\b0\par
Local variable\tab\tab\tab\tab int x;\tab\tab\tab Block\tab Automatic\tab None\tab\par
Static local variable\tab\tab\tab static int s_x;\tab\tab Block\tab Static\tab\tab None\tab\par
Dynamic variable\tab\tab\tab int *x \{ new int\{\} \};\tab Block\tab Dynamic\tab None\tab\par
Function parameter\tab\tab\tab void foo(int x)\tab\tab Block\tab Automatic\tab None\tab\par
External non-constant global variable\tab int g_x;\tab\tab\tab File\tab Static\tab\tab External\tab\tab Initialized or uninitialized\par
Internal non-constant global variable\tab static int g_x;\tab\tab File\tab Static\tab\tab Internal\tab\tab Initialized or uninitialized\par
Internal constant global variable\tab constexpr int g_x \{ 1 \};\tab\tab File\tab Static\tab\tab Internal\tab\tab Must be initialized\par
External constant global variable\tab extern const int g_x \{ 1 \};\tab\tab File\tab Static\tab\tab External\tab\tab Must be initialized\par
Inline constant global variable\tab\tab inline constexpr int g_x \{ 1 \}; File\tab Static\tab\tab External\tab\tab Must be initialized\par
\fs22\par
Forward declaration:\par
- You can use a forward declaration to access a function or variable in another file. The scope of the declared variable is as per usual (file scope for globals, block scope for locals).\par
\par
\b\fs20 Type\tab\tab\tab\tab\tab\tab Example\tab\tab\tab Notes\b0\par
Function forward declaration\tab\tab\tab void foo(int x);\tab\tab Prototype only, no function body\par
Non-constant variable forward declaration\tab\tab extern int g_x;\tab\tab Must be uninitialized\par
Const variable forward declaration\tab\tab extern const int g_x;\tab Must be uninitialized\par
Constexpr variable forward declaration\tab\tab extern constexpr int g_x;\tab Not allowed, constexpr cannot be forward declared\par
\fs22\par
What the heck is a storage class specifier?\par
- When used as part of an identifier declaration, the static and extern keywords are called storage class specifiers. In this context, they set the storage duration and linkage of the identifier.\par
- C++ supports 4 active storage class specifiers:\par
\par
\b\fs20 Specifier\tab\tab Meaning\tab\tab\tab\tab\tab\tab\tab\tab\tab Note\par
\b0 extern\tab\tab static (or thread_local) storage duration and external linkage\tab\par
static\tab\tab static (or thread_local) storage duration and internal linkage\tab\par
thread_local\tab thread storage duration\tab\tab\tab\tab\tab\tab\tab Introduced in C++11\par
mutable\tab\tab object allowed to be modified even if containing class is const\tab\par
auto\tab\tab automatic storage duration\tab\tab\tab\tab\tab\tab Deprecated in C++11\par
register\tab\tab automatic storage duration and hint to the compiler to place in a register \tab Deprecated in C++17\par
\fs22\par
- The term storage class specifier is typically only used in formal documentation.\b\par

\pard\sl240\slmult1\qc\par
6.12 Using declarations and using directives\par

\pard\sl240\slmult1 - \b0 A qualified name is a name that includes an associated scope. Most often, names are qualified with a namespace using the scope resolution operator (::).\par
- An unqualified name is a name that does not include a scoping qualifier. For example, cout and x are unqualified names, as they do not include an associated scope.\par
- One way to reduce the repetition of typing std:: over and over is to utilize a using declaration statement. A using declaration allows us to use an unqualified name (with no scope) as an alias for a qualified name.\par
- eg. using std::cout. You need to define this declaration statement for all names\par
- Another way to simplify things is to use a using directive. Slightly simplified, a using directive imports all of the identifiers from a namespace into the scope of the using directive.\par
- In modern C++, using directives generally offer little benefit (saving some typing) compared to the risk. Because using directives import all of the names from a namespace (potentially including lots of names you\rquote ll never use), the possibility for naming collisions to occur increases significantly (especially if you import the std namespace).\par
- If a using declaration or using directive is used within a block, the names are applicable to just that block (it follows normal block scoping rules). This is a good thing, as it reduces the chances for naming collisions to occur to just within that block.\par
- If a using declaration or using directive is used in the global namespace, the names are applicable to the entire rest of the file (they have file scope).\par
- Avoid using directives (particularly using namespace std;), except in specific circumstances. Using declarations are generally considered safe to use inside blocks. Limit their use in the global namespace of a code file, and never use them in the global namespace of a header file.\par
- Prefer explicit namespaces over using statements. Avoid using directives whenever possible. Using declarations are okay to use inside blocks.\b\par

\pard\sl240\slmult1\qc\par
6.13 Inline functions\par

\pard\sl240\slmult1 - \b0  One downside of using a function is that every time a function is called, there is a certain amount of performance overhead that occurs. \par
-  In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.\par
-  Inline expansion is a process where a function call is replaced by the code from the called function\rquote s definition.\par
- However, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches).\par
- A function that is eligible to have its function calls expanded is called an inline function.\par
- Historically, C++ provided the keyword inline, which was intended to be used as a hint to the compiler that a function would benefit from being expanded inline; but it isn't that useful.\par
- Do not use the inline keyword to request inline expansion for your functions. Modern optimizing compilers are typically very good at determining which functions should be made inline -- better than humans in most cases. As a result, the compiler will likely ignore or devalue any request you make to inline a function anyway.\par
- In modern C++, the inline concept has evolved to have a new meaning: multiple definitions are allowed in the program. This is true for functions as well as variables. Thus, if we mark a function as inline, then that function is allowed to have multiple definitions (in different files), as long as those definitions are identical.\par
\b\par

\pard\sl240\slmult1\qc\par
6.14 Constexpr and consteval functions\par

\pard\sl240\slmult1 - \b0 A constexpr function is a function whose return value may be computed at compile-time. To make a function a constexpr function, we simply use the constexpr keyword in front of the return type. This can save performance cost AND help maintain modularity\par
- To be eligible for compile-time evaluation, a function must have a constexpr return type and not call any non-constexpr functions. Additionally, a call to the function must have constexpr arguments (e.g. constexpr variables or literals).]\par
- Because constexpr functions may be evaluated at compile-time, the compiler must be able to see the full definition of the constexpr function at all points where the function is called. \par
- This means that a constexpr function called in multiple files needs to have its definition included into each such file -- which would normally be a violation of the one-definition rule. To avoid such problems, constexpr functions are implicitly inline, which makes them exempt from the one-definition rule.\par
- Key insight: Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases. Otherwise, you\rquote d need to have separate functions (a constexpr version and a non-constexpr version) -- and since return type isn\rquote t considered in function overload resolution, you\rquote d have to name the functions different things!\par
- Use std::is_constant_evaluated() (defined in the <type_traits> header) (bool return) to see whether the current function call is executing in a constant context (aka compile-time or not)\par
- C++20 introduces the keyword consteval, which is used to indicate that a function must evaluate at compile-time, otherwise a compile error will result. Such functions are called immediate functions.\par
- Use consteval if you have a function that must run at compile-time for some reason (e.g. performance).\par
- \b\par

\pard\sl240\slmult1\qc\par
6.15 Unnamed and inline namespaces\par

\pard\sl240\slmult1 - \b0 An unnamed namespace (also called an anonymous namespace) is a namespace that is defined without a name, like so: namespace \{\par
\tab code\par
\}\par
- All content declared in an unnamed namespace is treated as if it is part of the parent namespace. So even though function doSomething is defined in the unnamed namespace, the function itself is accessible from the parent namespace (which in this case is the global namespace), which is why we can call doSomething from main without any qualifiers.\par
- This might make unnamed namespaces seem useless. But the other effect of unnamed namespaces is that all identifiers inside an unnamed namespace are treated as if they had internal linkage, which means that the content of an unnamed namespace can\rquote t be seen outside of the file in which the unnamed namespace is defined.\par
- Unnamed namespaces are typically used when you have a lot of content that you want to ensure stays local to a given file, as it\rquote s easier to cluster such content in an unnamed namespace than individually mark all declarations as static. Unnamed namespaces will also keep user-defined types local to the file, something for which there is no alternative equivalent mechanism to do.\par
- An alternative is to use an inline namespace. An inline namespace is a namespace that is typically used to version content. Much like an unnamed namespace, anything declared inside an inline namespace is considered part of the parent namespace. However, inline namespaces don\rquote t give everything internal linkage.\par
\par
\b\par
}
 