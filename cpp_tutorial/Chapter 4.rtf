{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}{\f2\fnil\fcharset2 Symbol;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sl240\slmult1\qc\b\f0\fs22\lang9 4.1 Introduction to fundamental data types\par
\par

\pard\sl240\slmult1\b0 - The smallest unit of memory is a binary digit (also called a bit), which can hold a value of 0 or 1\par
- Memory is organized into sequential units called memory addresses (or addresses for short). \par
-  Each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits but it depends on PC to PC and compiler to compiler.\par
- Because all data on a computer is just a sequence of bits, we use a data type (often called a \ldblquote type\rdblquote  for short) to tell the compiler how to interpret the contents of memory in some meaningful way. \par
- If you assign an integer object the value 65, that value is converted to the sequence of bits 0100 0001 and stored in the memory assigned to the object.\par
-C++ comes with built-in support for many different data types. These are called fundamental data types, but are often informally called basic types, primitive types, or built-in types.\par
- Floating Point, Integral (Bool), Integral (Char), Integral (Integer), Null Pointer, Void\line - The _t suffix: Many modern types hace _t suffix\b\par

\pard\sl240\slmult1\qc\par
\par
4.2 Void\par
\par

\pard\sl240\slmult1\b0 - Void is the easiest of the data types to explain. Basically, void means \ldblquote no type\rdblquote !\par
- Use an empty parameter list instead of void to indicate that a function has no parameters. int getValue(void) no longer used\par
\b\par

\pard\sl240\slmult1\qc\par
4.3 Object sizes and the sizeof operator\par
\par

\pard\sl240\slmult1\b0 - The amount of memory that an object uses is based on its data type\par
- New programmers often focus too much on optimizing their code to use as little memory as possible. In most cases, this makes a negligible difference. Focus on writing maintainable code, and optimize only when and where the benefit will be substantive.\par
- \tab boolean\tab bool\tab\tab 1 byte\tab\par
\tab character\tab char\tab\tab 1 byte\par
\tab\tab\tab wchar_t\tab 1 byte\tab\par
\tab\tab\tab char16_t\tab 2 bytes\tab\par
\tab\tab\tab char32_t\tab 4 bytes\tab\par
\tab integer\tab\tab short\tab\tab 2 bytes\tab\par
\tab\tab\tab int\tab\tab 2 bytes\tab\par
\tab\tab\tab long\tab\tab 4 bytes\tab\par
\tab\tab\tab long long\tab 8 bytes\tab\par
\tab floating point\tab float\tab\tab 4 bytes\tab\par
\tab\tab\tab double\tab\tab 8 bytes\tab\par
\tab\tab\tab long double\tab 8 bytes\par
- The sizeof operator is a unary operator that takes either a type or a variable, and returns its size in bytes.\b\par

\pard\sl240\slmult1\qc\par
\par
4.4 Signed integers\par
\par

\pard\sl240\slmult1 - \b0 An integer is an integral type that can represent positive and negative whole numbers, including 0\par
- \tab short\tab\tab 16 bits\tab\par
\tab int\tab\tab 16 bits\par
\tab long\tab\tab 32 bits\tab\par
\tab long long\tab 64 bits\par
- By default, integers are signed, which means the number\rquote s sign is stored as part of the number (using a single bit called the sign bit). \par
- Prefer the shorthand types that do not use the int suffix or signed prefix.\par
- An n-bit signed variable has a range of -(2n-1) to 2n-1-1.\par
- Integer overflow (often called overflow for short) occurs when we try to store a value that is outside the range of the type. \par
- Signed integer overflow will result in undefined behavior.\par
- Be careful when using integer division, as you will lose any fractional parts of the quotient. However, if it\rquote s what you want, integer division is safe to use, as the results are predictable.\par
\b\par

\pard\sl240\slmult1\qc\par
4.5 Unsigned integers, and why to avoid them\par
\par

\pard\sl240\slmult1\b0 - Unsigned integers are integers that can only hold non-negative whole numbers.\par
- To define an unsigned integer, we use the unsigned keyword.\par
- An n-bit unsigned variable has a range of 0 to (2n)-1.\par
- When no negative numbers are required, unsigned integers are well-suited for networking and systems with little memory, because unsigned integers can store more positive numbers without taking up extra memory.\par
- Any number bigger than the largest number representable by the type simply \ldblquote wraps around\rdblquote  (sometimes called \ldblquote modulo wrapping\rdblquote )\par
- Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.\par
\b\par

\pard\sl240\slmult1\qc\par
\par
4.6 Fixed-width integers and size_t\par
\par

\pard\sl240\slmult1\b0  - Fixed-width integers: To addrtess the problem of not having variable int widths in various computers, fixed-width ints were proposed. fixed-width integers (in the stdint.h header) are guaranteed to be the same size on any architecture.\par
- They can be accessed by including the <cstdint> header, where they are defined inside the std namespace. Eg. std::int8_t or std::uint64_t\par
- The fixed-width integers have two downsides that are typically raised: \par
\tab - First, the fixed-width integers are not guaranteed to be defined on all architectures.\par
\tab - Second, if you use a fixed-width integer, it may be slower than a wider type on some architectures.\par
- The fast types (std::int_fast#_t and std::uint_fast#_t) provide the fastest signed/unsigned integer type with a width of at least # bits (where # = 8, 16, 32, or 64). For example, std::int_fast32_t will give you the fastest signed integer type that\rquote s at least 32 bits. \par
- The least types (std::int_least#_t and std::uint_least#_t) provide the smallest signed/unsigned integer type with a width of at least # bits (where # = 8, 16, 32, or 64). For example, std::uint_least32_t will give you the smallest unsigned integer type that\rquote s at least 32 bits.\par
- But even the fast and least types have their issues: because the size of the fast/least integers can vary, it\rquote s possible that your program may exhibit different behaviors on architectures where they resolve to different sizes.\par
-Avoid the 8-bit fixed-width integer types. If you do use them, note that they are often treated like chars.\par
- Our stance is that it\rquote s better to be correct than fast, better to fail at compile time than runtime -- therefore, we recommend avoiding the fast/least types in favor of the fixed-width types. \par
- Best practice:\par

\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 Prefer int when the size of the integer doesn\rquote t matter (e.g. the number will always fit within the range of a 2-byte signed integer). For example, if you\rquote re asking the user to enter their age, or counting from 1 to 10, it doesn\rquote t matter whether int is 16 or 32 bits (the numbers will fit either way). This will cover the vast majority of the cases you\rquote re likely to run across.\par
{\pntext\f2\'B7\tab}Prefer std::int#_t when storing a quantity that needs a guaranteed range.\par
{\pntext\f2\'B7\tab}Prefer std::uint#_t when doing bit manipulation or where well-defined wrap-around behavior is required.\par

\pard\sl240\slmult1 Avoid the following when possible:\par

\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 Unsigned types for holding quantities\par
{\pntext\f2\'B7\tab}The 8-bit fixed-width integer types\par
{\pntext\f2\'B7\tab}The fast and least fixed-width types\par
{\pntext\f2\'B7\tab}Any compiler-specific fixed-width integers -- for example, Visual Studio defines __int8, __int16, etc\'85\b\par

\pard\sl240\slmult1 - \b0 The sizeof operator itself has a type (std::size_t). This type has a size as well (usually the largest object your system can create).\par
- If you create object larger than the largest integral value of size_t, compiler will error out. \par
\b\par

\pard\sl240\slmult1\qc\par
\par
4.7 Introduction to scientific notation\par
\par

\pard\sl240\slmult1\b0 - Scientific notation: significand x 10\super exponent\par
- \nosupersub On computers, 1.2 x 10\f1\u8308? would be written as 1.2e4, and 5.9736 x 10\f0\'b2\f1\u8308? would be written as 5.9736e24.\par
\f0\lang1033 - Smaller numbers are like 9.1093822e-31 kg.\par
- How to convert numbers to scientific notation: \par

\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 Your exponent starts at zero.\par
{\pntext\f2\'B7\tab}Slide the decimal so there is only one non-zero digit to the left of the decimal.\par
{\pntext\f2\'B7\tab}Each place you slide the decimal to the left increases the exponent by 1.\par
{\pntext\f2\'B7\tab}Each place you slide the decimal to the right decreases the exponent by 1.\par
{\pntext\f2\'B7\tab}Trim off any leading zeros (on the left end of the significand)\par
{\pntext\f2\'B7\tab}Trim off any trailing zeros (on the right end of the significand) only if the original number had no decimal point. We\rquote re assuming they\rquote re not significant unless otherwise specified.\f1\lang9\par

\pard\sl240\slmult1\f0 - Here\rquote s the most important thing to understand: The digits in the significand (the part before the \lquote e\rquote ) are called the significant digits. The number of significant digits defines a number\rquote s precision\par

\pard\sl240\slmult1\qc\b\par
4.8 Floating point numbers\par
\par

\pard\sl240\slmult1\b0 - A floating point type variable is a variable that can hold a real number, such as 4320.0, -3.33, or 0.01226. The floating part of the name floating point refers to the fact that the decimal point can \ldblquote float\rdblquote ; that is, it can support a variable number of digits before and after the decimal point.\par
- There are three different floating point data types: float, double, and long double\par
- Note that by default, floating point literals default to type double. An f suffix is used to denote a literal of type float.\par
- Always make sure the type of your literals match the type of the variables they\rquote re being assigned to or used to initialize. Otherwise an unnecessary conversion will result, possibly with a loss of precision.\par
- Make sure you don\rquote t use integer literals where floating point literals should be used. This includes when initializing or assigning values to floating point objects, doing floating point arithmetic, and calling functions that expect floating point values.\par
- Size\tab\tab\tab\tab\tab Range\tab\tab\tab\tab\tab Precision\par
4 bytes\tab\tab\tab\tab\tab\'b11.18 x 10-38 to \'b13.4 x 1038\tab\tab 6-9 significant digits, typically 7\par
8 bytes\tab\tab\tab\tab\tab\'b12.23 x 10-308 to \'b11.80 x 10308\tab\tab 15-18 significant digits, typically 16\par
80-bits (typically uses 12 or 16 bytes)\tab\'b13.36 x 10-4932 to \'b11.18 x 104932\tab 18-21 significant digits\par
16 bytes\tab\tab\tab\tab\'b13.36 x 10-4932 to \'b11.18 x 104932\tab 33-36 significant digits\par
\par
- When outputting floating point numbers, std::cout has a default precision of 6 \par
- Also note that std::cout will switch to outputting numbers in scientific notation in some cases. Depending on the compiler, the exponent will typically be padded to a minimum number of digits. Fear not, 9.87654e+006 is the same as 9.87654e6, just with some padding 0\rquote s.\par
- We can override the default precision that std::cout shows by using an output manipulator function named std::setprecision(). Output manipulators alter how data is output, and are defined in the iomanip header.\par
- When precision is lost because a number can\rquote t be stored precisely, this is called a rounding error.\par
- Favor double over float unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.\par
- The result is a number that is precise to 16 significant digits (which type double guarantees), but the number is not exactly 0.1. Rounding errors may make a number either slightly smaller or slightly larger, depending on where the truncation happens.\par
-  Because floating point numbers tend to be inexact, comparing floating point numbers is generally problematic\par
- Rounding errors occur when a number can\rquote t be stored precisely. This can happen even with simple numbers, like 0.1. Therefore, rounding errors can, and do, happen all the time. Rounding errors aren\rquote t the exception -- they\rquote re the rule. Never assume your floating point numbers are exact. \par
- A corollary of this rule is: be wary of using floating point numbers for financial or currency data.\b\par
\b0 - There are two special categories of floating point numbers. The first is Inf, which represents infinity. Inf can be positive or negative. The second is NaN, which stands for \ldblquote Not a Number\rdblquote .\par
- Avoid division by 0 altogether, even if your compiler supports it.\par
-     Floating point numbers are useful for storing very large or very small numbers, including those with fractional components.\par
- Floating point numbers often have small rounding errors, even when the number has fewer significant digits than the precision. Many times these go unnoticed because they are so small, and because the numbers are truncated for output. However, comparisons of floating point numbers may not give the expected results. Performing mathematical operations on these values will cause the rounding errors to grow larger.\b\par

\pard\sl240\slmult1\qc\par
\par
4.9 Boolean values\par
\par

\pard\sl240\slmult1 - \b0  Boolean type (note: Boolean is properly capitalized in the English language because it\rquote s named after its inventor, George Boole): Boolean variables are variables that can have only two possible values: true, and false.\par
- Default initialize is to false \par
- the logical NOT operator (!) can be used to flip a Boolean value from true to false, or false to true:\par
- They are stored as integers and evaluate to 0 and 1\par
- If you want std::cout to print \ldblquote true\rdblquote  or \ldblquote false\rdblquote  instead of 0 or 1, you can use std::boolalpha.\par
- std::cin only accepts two inputs for boolean variables: 0 and 1 (not true or false)\par
\b\par

\pard\sl240\slmult1\qc\par
4.10 Introduction to if statements\par
\par

\pard\sl240\slmult1\b0 - An if statement allows us to execute one (or more) lines of code only if some condition is true.\par
- Syntax: \par

\pard\li720\sl240\slmult1 if (condition)\par
    true_statement;\par
else\par
    false_statement;\par

\pard\sl240\slmult1 - A condition (also called a conditional expression) is an expression that evaluates to a Boolean value.\par
- We can chain if statements with else if ( )\b\par

\pard\sl240\slmult1\qc\par
\par
4.11 Chars\par
\par

\pard\sl240\slmult1\b0 -  The char data type was designed to hold a character. A character can be a single letter, number, symbol, or whitespace.\par
- The char data type is an integral type, meaning the underlying value is stored as an integer. The integer stored by a char variable are intepreted as an ASCII character.\par
- ASCII goes from 0 - 127 (32-127 are printable characters)\par
- Be careful not to mix up character numbers with integer numbers. The following two initializations are not the same:\par
\tab char ch\{5\}; // initialize with integer 5 (stored as integer 5)\par
\tab char ch\{'5'\}; // initialize with code point for '5' (stored as integer 53)\par
- Note that std::cin will let you enter multiple characters. However, variable ch can only hold 1 character. Consequently, only the first input character is extracted into variable ch. The rest of the user input is left in the input buffer that std::cin uses, and can be extracted with subsequent calls to std::cin.\par
- Char is defined by C++ to always be 1 byte in size.\par
- Escape sequences: n escape sequence starts with a \lquote\\\rquote  (backslash) character, and then a following letter or number.\par
- Single chars are always put in single quotes, strings in double quotes\par
- Put stand-alone chars in single quotes (e.g. \lquote t\rquote  or \lquote\\n\rquote , not \ldblquote t\rdblquote  or \ldblquote\\n\rdblquote ). This helps the compiler optimize more effectively.\par
- Much like ASCII maps the integers 0-127 to American English characters, other character encoding standards exist to map integers (of varying sizes) to characters in other languages. The most well-known mapping outside of ASCII is the Unicode standard, which maps over 144,000 integers to characters in many different languages. Because Unicode contains so many code points, a single Unicode code point needs 32-bits to represent a character (called UTF-32). However, Unicode characters can also be encoded using multiple 16-bit or 8-bit characters (called UTF-16 and UTF-8 respectively).\b\par

\pard\sl240\slmult1\qc\par
\par
4.12 Introduction to type conversion and static_cast\par
\par

\pard\sl240\slmult1 - \b0 Implicit type conversion: The process of converting a value from one type to another type is called type conversion. When the compiler does type conversion for us, we call this implicit type conversion.\par
- Implicit type conversion warnings: Happens when going from float to int (whenever there is a data loss)\par
- We can make sure we aren't doing implicit type conversion by using brace initilization eg. int a \{5\}\par
- Explicit type conversion allow us (the programmer) to explicitly tell the compiler to convert a value from one type to another type, and that we take full responsibility for the result of that conversion (meaning that if the conversion results in the loss of value, it\rquote s our fault).\par
- static_cast operator: static_cast<new_type>(expression)\par
- Whenever you see C++ syntax (excluding the preprocessor) that makes use of angled brackets (<>), the thing between the angled brackets will most likely be a type. This is typically how C++ deals with concepts that need a parameterizable type.\par
- eg. static_cast<int>(5.5) Because we\rquote re now explicitly requesting that double value 5.5 be converted to an int value, the compiler will not generate a warning about a possible loss of data upon compilation (meaning we can leave \ldblquote treat warnings as errors\rdblquote  enabled).\par
-  The static_cast operator will produce undefined behavior if the value being converted doesn\rquote t fit in range of the new type\par
- Most compilers define and treat std::int8_t and std::uint8_t (and the corresponding fast and least fixed-width types) identically to types signed char and unsigned char respectively.\par
eg. std::int8_t myint\{65\} on some will print as 65, but on others will be treated as a char and print A instead\par
-\b\par

\pard\sl240\slmult1\qc\par
4.13 An introduction to std::string\par
\par

\pard\sl240\slmult1\b0 - In C++, strings aren\rquote t a fundamental type (they\rquote re actually a compound type, and defined in the C++ standard library rather than as part of the core language)\par
- std::string: To use strings in C++, we first need to #include the <string> header to bring in the declarations for std::string.\par
- It turns out that when using operator>> to extract a string from cin, operator>> only returns characters up to the first whitespace it encounters. Any other characters are left inside std::cin, waiting for the next extraction.\par
- To read a full line of input into a string, use the std::getline() function. \par
- If using std::getline to read strings, use the std::ws input manipulator to ignore leading whitespace.\par
- Note that instead of asking for the string length as length(myName), we say myName.length(). The length() function isn\rquote t a normal standalone function -- it\rquote s a special type of function that is nested within std::string called a member function\par
- Also note that std::string::length() returns an unsigned integral value (most likely size_t). If you want to assign the length to an int variable, you should static_cast it to avoid compiler warnings about signed/unsigned conversions: \par
\tab int length = static_cast<int>(myName.length());\par
\b\par

\pard\sl240\slmult1\qc\par
\par
4.14 Literal constants\par
\par

\pard\sl240\slmult1 - \b0 In programming, a constant is a fixed value that may not be changed. C++ has two kinds of constants: literal constants, and symbolic constants. \par
- Literal constants (usually just called literals) are unnamed values inserted directly into the code.\par
- If the default type of a literal is not as desired, you can change the type of a literal by adding a suffix: l for long, f for float, etc.\par
- When initializing literals, make sure they have suffix that corresponds to the data type. Eg. float f \{ 4.1 \}; // warning: 4.1 is a double literal, not a float literal. To fix, say float f \{4.1f\}\par
- To use a hexadecimal literal, prefix your literal with 0x: Consider a 32-bit integer with value 0011 1010 0111 1111 1001 1000 0010 0110. Because of the length and repetition of digits, that\rquote s not easy to read. In hexadecimal, this same value would be: 3A7F 9826. This makes hexadecimal values useful as a concise way to represent a value in memory. For this reason, hexadecimal values are often used to represent memory addresses or raw values in memory.\par
- In C++14, we can assign binary literals by using the 0b prefix\par
- Because long literals can be hard to read, C++14 also adds the ability to use a quotation mark (\lquote ) as a digit separator.\par
- By default, C++ prints values in decimal. However, you can tell it to print in other formats. Printing in decimal, octal, or hex is easy via use of std::dec, std::oct, and std::hex\par
- Printing in binary is a little harder, as std::cout doesn\rquote t come with this capability built-in. Fortunately, the C++ standard library includes a type called std::bitset that will do this for us (in the <bitset> header). To use std::bitset, we can define a std::bitset variable and tell std::bitset how many bits we want to store. The number of bits must be a compile time constant. std::bitset can be initialized with an unsigned integral value (in any format, including decimal, octal, hex, or binary).\par
\b\par

\pard\sl240\slmult1\qc\par
\par
4.15 Symbolic constants: const and constexpr variables\par
\par

\pard\sl240\slmult1\b0 - Defining this value as a constant helps ensure that this value isn\rquote t accidentally changed.\par
- To make a variable constant, simply put the const keyword either before or after the variable type\par
- Constant variables are sometimes called symbolic constants (as opposed to literal constants, which are just values that have no name).\par
- C++ actually has two different kinds of constants. Runtime constants are constants whose initialization values can only be resolved at runtime (when your program is running). \par
- Compile-time constants enable the compiler to perform optimizations that aren\rquote t available with runtime constants. For example, whenever gravity is used, the compiler can simply substitute the identifier gravity with the literal double 9.8.\par
- To help provide more specificity, C++11 introduced the keyword constexpr, which ensures that a constant must be a compile-time constant\par
- A constant expression is an expression that can be evaluated at compile-time.\par
- If you need constexpr strings, use std::string_view instead\par
- A magic number is a literal (usually a number) that either has an unclear meaning or is used multiple times. Avoid them and use symbolic constants instead\par
- \b\par

\pard\sl240\slmult1\qc\par
}
 