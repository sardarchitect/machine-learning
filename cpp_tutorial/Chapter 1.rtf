{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sl240\slmult1\qc\b\f0\fs22\lang9 1.1 Statements and the structure of a program\par
\b0\par

\pard\sl240\slmult1 - A statement is a type of instruction that causes the program to perform some action\par
- Most statements end in semicolon.\par

\pard\li720\sl240\slmult1\par

\pard\sl240\slmult1 Functions:\par
- A function is a collection of statements that executes sequentially (in order, from top to bottom) \par
- #include <iostream> is a preprocessor directive, basically serves like "import" in javascript/python\par
-<<  std::cout stands for "character output" and << operator allows us to send letters or numbers to the console\par
\par

\pard\sl240\slmult1\qc\par
\b 1.2 Comments\par
\b0\par

\pard\sl240\slmult1 - A comment is a programmer-readable note that is inserted directly into the source code of the program. Comments are ignored by the compiler and are for the programmer\rquote s use only.\par
- Single-line comments: //\par
- Multi-line comments: /* */\par
-     At the library, program, or function level, use comments to describe what.\par
- Inside the library, program, or function, use comments to describe how.\par
- At the statement level, use comments to describe why.\par
- Comment your code liberally, and write your comments as if speaking to someone who has no idea what the code does. Don\rquote t assume you\rquote ll remember why you made specific choices.\par
\par
\par

\pard\sl240\slmult1\qc\b 1.3 Introduction to objects and variables\par
\b0\par

\pard\sl240\slmult1 - Programs need data to "do something". This data is stored in binary after the program is compiled.\par
- RAM: Random Access Memory\par
- Value: Single piece of data stored in memory somewhere\par
- Object: Region of storage (usually memory) that has a value and other associated properties.\par
- Variable: A Named object\par
- Identifier: Name of the object\par
\par
Variables\par
- Variable instantiation: In order to create a variable, we use a special kind of declaration statement called a definition\par
-  Variables are instantiated at runtime\par
- Data Type tells compiler what type of value that variable will store.\par
- In C++, the type of a variable must be known at compile-time (when the program is compiled), and that type can not be changed without recompiling the program.\par
- In C++, we use variables to access memory. Variables have an identifier, a type, and a value (and some other attributes that aren\rquote t relevant here). A variable\rquote s type is used to determine how the value in memory should be interpreted.\par
\par
\par

\pard\sl240\slmult1\qc\b 1.4 Variable assignment and initialization\par
\b0\par

\pard\sl240\slmult1 - After a variable has been defined, you can give it a value (in a separate statement) using the = operator. This process is called copy assignment (or just assignment) for short. The = operator is called the assignment operator.\par
- When a variable is defined, you can also provide an initial value for the variable at the same time. This is called initialization. The value used to initialize a variable is called an initializer.\par
- There are 4 basic ways to initialize variables in C++:\par

\pard\li720\sl240\slmult1 int a; // no initializer - Default Initialization \par
int b = 5; // initializer after equals sign - Copy Initialization\par
int c( 6 ); // initializer in parenthesis - Direct Initialization (essentially the same as copy)\par
int d \{ 7 \}; // initializer in braces - Brace Initialization or  uniform initialization or list initialization, comes in 3 forms:\par
\tab int width \{ 5 \}; // direct brace initialization of value 5 into variable width (preferred)\par
\tab int height = \{ 6 \}; // copy brace initialization of value 6 into variable height\par
\tab int depth \{\}; // value initialization\par
Brace initialization has the added benefit of disallowing \ldblquote narrowing\rdblquote  conversions. This means that if you try to use brace initialization to initialize a variable with a value it can not safely hold, the compiler will throw a warning or an error. Copy and direct initialization will just drop the decimal part of a int assignment. Favor initialization using braces whenever possible.\par

\pard\sl240\slmult1 - When a variable is initialized with empty braces, value initialization takes place. In most cases, value initialization will initialize the variable to zero (or empty, if that\rquote s more appropriate for a given type). In such cases where zeroing occurs, this is called zero initialization.\par
- When should I initialize with \{ 0 \} vs \{\}? Use an explicit initialization value if you\rquote re actually using that value. Use value initialization if the value is temporary and will be replaced.\par
- Initialization gives a variable an initial value at the point when it is created. Assignment gives a variable a value at some point after the variable is created.\par
\par

\pard\sl240\slmult1\qc\b 1.5 Introduction to iostream: cout, cin, and endl\par
\b0\par

\pard\sl240\slmult1 - #include <iostream> used to import iostream library\par
- std::cout - character output variable from standard library\par
- << - insert operator. Eg. std::cout << "Hello" << " world!";\par
- std::endl : for printing newline character.  This moves the cursor to the next line, and it makes sure that the output shows up on the screen immediately (this is called flushing the output). std::cout is already flushing the output\par
- \\n is a more efficient way to use newline character. \par
- std::cin (which stands for \ldblquote character input\rdblquote ) reads input from keyboard using the extraction operator (>>)\par
\par
\par

\pard\sl240\slmult1\qc\b 1.6 Uninitialized variables and undefined behavior\par
\b0\par

\pard\sl240\slmult1 - Unlike some programming languages, C/C++ does not initialize most variables to a given value (such as zero) automatically.\par
- Uninitalized variable's default value is whatever (garbage) value happens to already be in that memory location!\par
- \ldblquote always initialize your variables\rdblquote  best practice.\par
\par
Undefined behavior:\par
- Undefined behavior (often abbreviated UB) is the result of executing code whose behavior is not well defined by the C++ language.\par
- Code implementing undefined behavior may exhibit any of the following symptoms:\par
    Your program produces different results every time it is run.\par
    Your program consistently produces the same incorrect result.\par
    Your program behaves inconsistently (sometimes produces the correct result, sometimes not).\par
    Your program seems like its working but produces incorrect results later in the program.\par
    Your program crashes, either immediately or later.\par
    Your program works on some compilers but not others.\par
    Your program works until you change some other seemingly unrelated code.\par
\par
\par

\pard\sl240\slmult1\qc\b 1.7 Keywords and naming identifiers\par
\b0\par

\pard\sl240\slmult1 - C++ reserves a set of 92 words (as of C++20) for its own use. These words are called keywords (or reserved words), and each of these keywords has a special meaning within the C++ language.\par
- Idenitfier naming rules\par

\pard\li720\sl240\slmult1 - The identifier can not be a keyword. Keywords are reserved.\par
- The identifier can only be composed of letters (lower or upper case), numbers, and the underscore character. That means -the name can not contain symbols (except the underscore) nor whitespace (spaces or tabs).\par
- The identifier must begin with a letter (lower or upper case) or an underscore. It can not start with a number.\par
- C++ is case sensitive, and thus distinguishes between lower and upper case letters. nvalue is different than nValue is different than NVALUE.\par

\pard\sl240\slmult1 - Naming conventions:\par
\tab - Variable and most function names should begin with a lowercase letter\par
\tab - Structs, classes, and enumerations typically start with capital letters\par
\tab - multiword variables can have snake_case or intercapped camelCase. \par
\tab - You should avoid naming your identifiers starting with an underscore, as these names are typically reserved for OS, \tab library, and/or compiler use\par
\tab -  your identifiers should make clear what the value they are holding means\par
\par
\par

\pard\sl240\slmult1\qc\b 1.8 Whitespace and basic formatting\par

\pard\sl240\slmult1\b0\par
- Whitespace is a term that refers to characters that are used for formatting purposes. In C++, this refers primarily to spaces, tabs, and newlines. The C++ compiler generally ignores whitespace, with a few minor exceptions (when processing text literals). For this reason, we say that C++ is a whitespace-independent language.\b\par
\b0 -Best practice: Your lines should be no longer than 80 chars in length.\par
- Using the automatic formatting feature is highly recommended to keep your code\rquote s formatting style consistent.\par
\b\par

\pard\sl240\slmult1\qc 1.9 Introduction to literals and operators\par

\pard\sl240\slmult1\b0 - A literal (also known as a literal constant) is a fixed value that has been inserted directly into the source code.\par
- Literals and variables both have a value (and a type). However, the value of a literal is fixed and can\rquote t be changed (hence it being called a constant), whereas the value of a variable can be changed through initialization and assignment.\par
- In mathematics, an operation is a mathematical calculation involving zero or more input values (called operands) that produces a new value (called an output value). The specific operation to be performed is denoted by a construct (typically a symbol or pair of symbols) called an operator.\par
- The number of operands that an operator takes as input is called the operator\rquote s arity \par
- Unary, Binary, Ternary\par
- Parenthesis first, then Exponents, then Multiplication & Division, then Addition & Subtraction.\par
\b\par

\pard\sl240\slmult1\qc 1.10 Introduction to expressions\par

\pard\sl240\slmult1 - \b0 An expression is a combination of literals, variables, operators, and function calls that can be executed to produce a singular value. The process of executing an expression is called evaluation, and the single value produced is called the result of the expression.\par
- expressions are always evaluated as a part of statements\par
- Wherever you can use a single value in C++, you can use an expression instead, and the expression will be evaluated to produce a single value.\par
- Values calculated in an expression are discarded at the end of the expression.\par
- Statements are used when we want the program to perform an action. Expressions are used when we want the program to calculate a value.\b\par
\par

\pard\sl240\slmult1\qc 1.11 Developing your first program\par
\par

\pard\sl240\slmult1 - \b0 New programmers often try to write an entire program all at once, and then get overwhelmed when it produces a lot of errors. A better strategy is to add one piece at a time, make sure it compiles, and test it. Then when you\rquote re sure it\rquote s working, move on to the next piece.\par
- \ldblquote You have to write a program once to know how you should have written it the first time.\rdblquote  \par
\b\par
\b0\par
}
 