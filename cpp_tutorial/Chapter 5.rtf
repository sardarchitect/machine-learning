{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sl240\slmult1\qc\b\f0\fs22\lang9 Operators\par
5.1 Operator precedence and associativity\par

\pard\sl240\slmult1\b0\par
-  An expression that has multiple operators is called a compound expression. \par
- Operator precedence: The order in which operators are evaluated in a compound expression is determined by an operator\rquote s precedence.\par
- Associativity: If two operators with the same precedence level are adjacent to each other in an expression, the operator\rquote s associativity tells the compiler whether to evaluate the operators from left to right or from right to left.\par
- In order to reduce mistakes and make your code easier to understand without referencing a precedence table, it\rquote s a good idea to parenthesize any non-trivial compound expression, so it\rquote s clear what your intent is.\par
- Expressions with a single assignment operator do not need to have the right operand of the assignment wrapped in parenthesis.\par
- Warning: In many cases, the operands in a compound expression may evaluate in any order. This includes function calls and the arguments to those function calls. Best practice: Outside of the operator precedence and associativity rules, assume that the parts of an expression could evaluate in any order. Ensure that the expressions you write are not dependent on the order of evaluation of those parts.\par
\b\par
\par

\pard\sl240\slmult1\qc 5.2 Arithmetic operators\par
\par

\pard\sl240\slmult1 - \b0 There are two unary arithmetic operators, plus (+), and minus (-). As a reminder, unary operators are operators that only take one operand.\par
- There are 5 binary arithmetic operators. Binary operators are operators that take a left and right operand (+, -, *, /, %)\par
- If either (or both) of the operands are floating point values, the division operator performs floating point division. Floating point division returns a floating point value, and the fraction is kept. For example, 7.0 / 4 = 1.75, 7 / 4.0 = 1.75, and 7.0 / 4.0 = 1.75. As with all floating point arithmetic operations, rounding errors may occur.\par
- If both of the operands are integers, the division operator performs integer division instead. Integer division drops any fractions and returns an integer value. For example, 7 / 4 = 1 because the fractional portion of the result is dropped. \par
- Because writing statements such as x = x + 4 is so common, C++ provides five arithmetic assignment operators for convenience. Instead of writing x = x + 4, you can write x += 4. Instead of x = x * y, you can write x *= y\par

\pard\sl240\slmult1\qc\b\par
\par
5.3 Modulus and Exponentiation\par
\par

\pard\sl240\slmult1\b0 - The modulus operator (also informally known as the remainder operator) is an operator that returns the remainder after doing an integer division. For example, 7 / 4 = 1 remainder 3. Therefore, 7 % 4 = 3.\par
- C++ does not include an exponent operator. To do exponents in C++, #include the <cmath> header, and use the pow() function. eg. std::pow(3.0, 4.0)\par
- You are better off using your own function for exponential rather than standard library one as it will allow for less error and more efficiency\par
\b\par
\par

\pard\sl240\slmult1\qc 5.4 Increment/decrement operators, and side effects\par
\par

\pard\sl240\slmult1\b0 - Incrementing (adding 1 to) and decrementing (subtracting 1 from) a variable are both so common that they have their own operators.\par
- \par
Prefix increment (pre-increment)\tab ++\tab ++x\tab Increment x, then return x\par
Prefix decrement (pre-decrement)\tab\f1\endash\endash\tab\endash\endash x\tab Decrement x, then return x\par
Postfix increment (post-increment)\tab ++\tab x++\tab Copy x, then increment x, then return the copy\par
Postfix decrement (post-decrement)\tab\endash\endash\tab x\endash\endash\tab Copy x, then decrement x, then return the copy\par
\f0\lang1033 - In postfix inc/dec, a temporary copy of x is made that starts with the same value as x (5). Then the actual x is incremented from 5 to 6. Then the copy of x (which still has value 5) is returned and assigned to y. Then the temporary copy is discarded. \par
- Strongly favor the prefix version of the increment and decrement operators, as they are generally more performant, and you\rquote re less likely to run into strange issues with them.\par
- Side effects: A function or expression is said to have a side effect if it does anything that persists beyond the life of the function or expression itself.\par
- Warning: C++ does not define the order of evaluation for function arguments or operator operands.\par
- Warning: Don\rquote t use a variable that has a side effect applied to it more than once in a given statement. If you do, the result may be undefined.\par
\b\lang9\par

\pard\sl240\slmult1\qc 5.5 Comma and conditional operators\par
\par

\pard\sl240\slmult1\b0 - The comma operator (,) allows you to evaluate multiple expressions wherever a single expression is allowed. The comma operator evaluates the left operand, then the right operand, and then returns the result of the right operand.\par
- Note that comma has the lowest precedence of all the operators, even lower than assignment. Because of this, the following two lines of code do different things:\par
z = (a, b); // evaluate (a, b) first to get result of b, then assign that value to variable z.\par
z = a, b; // evaluates as "(z = a), b", so z gets assigned the value of a, and b is evaluated and discarded.\par
- Best practice: Avoid using the comma operator, except within for loops.\par
-The conditional operator: The conditional operator (?:) (also sometimes called the \ldblquote arithmetic if\rdblquote  operator) is a ternary operator (it takes 3 operands). Because it has historically been C++\rquote s only ternary operator, it\rquote s also sometimes referred to as \ldblquote the ternary operator\rdblquote .\par
- Note that the ?: operator has a very low precedence. If doing anything other than assigning the result to a variable, the whole ?: operator also needs to be wrapped in parentheses\par
- To properly comply with C++\rquote s type checking, either the type of both expressions in a conditional statement must match, or the both expressions must be convertible to a common type.\par
- std::cout << (x != 5 ? x : "x is 5"); // won't compile\line The above example won\rquote t compile. One of the expressions is an integer, and the other is a string literal. The compiler is unable to determine a common type for expressions of these types. In such cases, you\rquote ll have to use an if/else.\par
- Only use the conditional operator for simple conditionals where you use the result and where it enhances readability.\par
\b\par

\pard\sl240\slmult1\qc\par
5.6 Relational operators and floating point comparisons\par
\par

\pard\sl240\slmult1\b0 - Relational operators are operators that let you compare two values. There are 6 relational operators:\par
\par
Operator\tab\tab Symbol\tab Form\tab Operation\par
Greater than\tab\tab >\tab x > y\tab true if x is greater than y, false otherwise\par
Less than\tab\tab <\tab x < y\tab true if x is less than y, false otherwise\par
Greater than or equals\tab >=\tab x >= y\tab true if x is greater than or equal to y, false otherwise\par
Less than or equals\tab <=\tab x <= y\tab true if x is less than or equal to y, false otherwise\par
Equality\tab\tab ==\tab x == y\tab true if x equals y, false otherwise\par
Inequality\tab\tab !=\tab x != y\tab true if x does not equal y, false otherwise\par
\par
- You have already seen how most of these work, and they are pretty intuitive. Each of these operators evaluates to the boolean value true (1), or false (0).\par
- If a high level of precision is required, comparing floating point values using any of the relational operators can be dangerous. This is because floating point values are not precise, and small rounding errors in the floating point operands may cause unexpected results\par
- Avoid using operator== and operator!= with floating point operands.\par
- The most common method of doing floating point equality involves using a function that looks to see if two numbers are almost the same. If they are \ldblquote close enough\rdblquote , then we call them equal. The value used to represent \ldblquote close enough\rdblquote  is traditionally called epsilon. Epsilon is generally defined as a small positive number (e.g. 0.00000001, sometimes written 1e-8).\par

\pard\sl240\slmult1\qc\b\par
\par
5.7 Logical operators\par
\par

\pard\sl240\slmult1\b0 - Logical operators provide us with the capability to test multiple conditions.\par
- C++ has 3 logical operators:\par
\par
Operator\tab Symbol\tab Form\tab Operation\par
Logical NOT\tab !\tab !x\tab true if x is false, or false if x is true\par
Logical AND\tab &&\tab x && y\tab true if both x and y are true, false otherwise\par
Logical OR\tab ||\tab x || y\tab true if either x or y are true, false otherwise\par
\b\par
\b0 - If logical NOT is intended to operate on the result of other operators, the other operators and their operands need to be enclosed in parentheses.\par
\b - \b0 The logical OR operator is used to test whether either of two conditions is true. If the left operand evaluates to true, or the right operand evaluates to true, or both are true, then the logical OR operator returns true. Otherwise it will return false.\par
- The logical AND operator is used to test whether both operands are true. If both operands are true, logical AND returns true. Otherwise, it returns false.\par
- In order for logical AND to return true, both operands must evaluate to true. If the first operand evaluates to false, logical AND knows it must return false regardless of whether the second operand evaluates to true or false. In this case, the logical AND operator will go ahead and return false immediately without even evaluating the second operand! This is known as short circuit evaluation, and it is done primarily for optimization purposes. Similarly, if the first operand for logical OR is true, then the entire OR condition has to evaluate to true, and the second operand won\rquote t be evaluated.\par
-  Short circuit evaluation may cause Logical OR and Logical AND to not evaluate one operand. Avoid using expressions with side effects in conjunction with these operators.\par
- Logical AND has higher precedence than logical OR, thus logical AND operators will be evaluated ahead of logical OR operators (unless they have been parenthesized).\par
- When mixing logical AND and logical OR in a single expression, explicitly parenthesize each operation to ensure they evaluate how you intend.\par
- De Morgan\rquote s law: Many programmers also make the mistake of thinking that !(x && y) is the same thing as !x && !y. Unfortunately, you can not \ldblquote distribute\rdblquote  the logical NOT in that manner.\par
- De Morgan\rquote s law tells us how the logical NOT should be distributed in these cases:\par
\tab !(x && y) is equivalent to !x || !y\par
\tab !(x || y) is equivalent to !x && !y\par
In other words, when you distribute the logical NOT, you also need to flip logical AND to logical OR, and vice-versa! This can sometimes be useful when trying to make complex expressions easier to read.\line - \b\par

\pard\sl240\slmult1\qc\par
\par
}
 