{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset2 Symbol;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sl240\slmult1\qc\b\f0\fs22\lang9 2.1 Introduction to functions\par
\par

\pard\sl240\slmult1\b0 - A function is a reusable sequence of statements designed to do a particular job.\par
- Function calls tell CPU to pause current function and come back to the same point after executing/calling the new function.\par
- Function initiating the function called is called the caller, function being called is callee or called function.\par
- eg. \par
return-type identifier() \{\par
//function body\par
\}\par
- Don\rquote t forget to include parentheses () after the function\rquote s name when making a function call.\par
- In C++, functions cannot be defined inside other functions.\par
- "foo" is a metasyntactic or placeholder variable for demo purposes\par
\b\par
\par

\pard\sl240\slmult1\qc 2.2 Function return values (value-returning functions)\par

\pard\sl240\slmult1\par
\b0 - Return type needs to be defined, can be void\par
- Return statement exits the function and sends value to caller. This is called return by value.\par
- When a called function returns a value, the caller may decide to use that value in an expression or statement (e.g. by assigning it to a variable, or sending it to std::cout) or ignore it (by doing nothing else).\par
- The return value from main is sometimes called "Status Code" or "Exit Code" or "Return Code". Should return 0 if program ran successfully.\par
- A function that returns a value is called a value-returning function. A function is value-returning if the return type is anything other than void. A value-returning function must return a value of that type (using a return statement), otherwise undefined behavior will result.\par
- Make sure your functions with non-void return types return a value in all cases. Failure to return a value from a value-returning function will cause undefined behavior.\par
- A value-returning function can only return a single value back to the caller each time it is called.\par
- DRY: Don't Repeat Yourself\par
\par
\b\par

\pard\sl240\slmult1\qc 2.3 Void functions (non-value returning functions)\par
\par

\pard\sl240\slmult1\b0 - Functions are not required to return a value back to the caller. To tell the compiler that a function does not return a value, a return type of void is used\par
- A function that does not return a value is called a non-value returning function (or a void function). A void function will automatically return to the caller at the end of the function. No return statement is required.\par
- Returning a value from a void function is a compile error\par
- A return statement that is not the last statement in a function is called a early return. \par
\b\par

\pard\sl240\slmult1\qc\par
2.4 Introduction to function parameters and arguments\par

\pard\sl240\slmult1\b0\par
- A function parameter is a variable used in a function. Function parameters work almost identically to variables defined inside the function, but with one difference: they are always initialized with a value provided by the caller of the function.\par
- An argument is a value that is passed from the caller to the function when a function call is made\par
- When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is copied into the matching parameter. This process is called pass by value.\par
\par
\b\par

\pard\sl240\slmult1\qc 2.5 Introduction to local scope\par
\par

\pard\sl240\slmult1\b0 -  Function parameters, as well as variables defined inside the function body, are called local variables \par
- Function parameters are created and initialized when the function is entered, and variables within the function body are created and initialized at the point of definition.\par
-  Local variables are destroyed in the opposite order of creation at the end of the set of curly braces in which it is defined (or for a function parameter, at the end of the function)\par
- An identifier\rquote s scope determines where the identifier can be accessed within the source code\par
- The term \ldblquote going out of scope\rdblquote  is typically applied to objects rather than identifiers. \par
-  Remember, lifetime is a runtime property, and scope is a compile-time property\par
- Names used for function parameters or variables declared in a function body are only visible within the function that declares them. This means local variables within a function can be named without regard for the names of variables in other functions. This helps keep functions independent.\par
- Define your local variables as close to their first use as reasonable.\par
\par
\b\par

\pard\sl240\slmult1\qc 2.6 Why functions are useful, and how to use them effectively\par
\par

\pard\sl240\slmult1\b0 - Organization \par
- Reusability\par
- Testing\par
- Extensibility\par
- Abstraction\par
-\- New programmers often combine calculating a value and printing the calculated value into a single function. However, this violates the \ldblquote one task\rdblquote  rule of thumb for functions. A function that calculates a value should return the value to the caller and let the caller decide what to do with the calculated value (such as call another function to print the value). \par
\par
\b\par

\pard\sl240\slmult1\qc 2.7 Forward declarations and definitions\par
\par

\pard\sl240\slmult1\b0 - A forward declaration allows us to tell the compiler about the existence of an identifier before actually defining the identifier.\par
- To write a forward declaration for a function, we use a declaration statement called a function prototype.\par
- The function prototype consists of the function\rquote s return type, name, parameters, but no function body (the curly braces and everything in between them), terminated with a semicolon.\line - eg. int add(int x, int y);\par
- It is worth noting that function prototypes do not need to specify the names of the parameters. eg. int add(int, int);\par
- When defining function prototypes, keep the parameter names. You can easily create forward declarations by copy/pasting your function\rquote s prototype and adding a semicolon.\par
- If a forward declaration is made and the function is called, but the program never defines the function, the program will compile okay, but the linker will complain that it can\rquote t resolve the function call. \par
- A definition actually implements (for functions or types) or instantiates (for variables) the identifier.\par
- A definition is needed to satisfy the linker. \par
- The one definition rule (or ODR for short) is a well-known rule in C++. The ODR has three parts:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li1440\sl240\slmult1 Within a given file, a function, variable, type, or template can only have one definition.\par
{\pntext\f1\'B7\tab}Within a given program, a variable or normal function can only have one definition. This distinction is made because  programs can have more than one file (we\rquote ll cover this in the next lesson).\par
{\pntext\f1\'B7\tab}Types, templates, inline functions, and inline variables are allowed to have identical definitions in different files. We haven\rquote t covered what most of these things are yet, so don\rquote t worry about this for now -- we\rquote ll bring it back up when it\rquote s relevant.\par

\pard\sl240\slmult1 Violating part 1 of the ODR will cause the compiler to issue a redefinition error. Violating ODR part 2 will likely cause the linker to issue a redefinition error. Violating ODR part 3 will cause undefined behavior.\par
- A declaration is a statement that tells the compiler about the existence of an identifier and its type information.\par
- All definitions also serve as declarations.\par
- Declarations that aren't definitions are called pure declaration.\par
\par
\b\par

\pard\sl240\slmult1\qc 2.8 Programs with multiple code files\par
\par

\pard\sl240\slmult1\b0 - #include includes all the code from one file to another\b\par

\pard\sl240\slmult1\qc\par
2.9 Naming collisions and an introduction to namespaces\par
\par

\pard\sl240\slmult1\b0 -  If two identical identifiers are introduced into the same program in a way that the compiler or linker can\rquote t tell them apart, the compiler or linker will produce an error. This error is generally referred to as a naming collision (or naming conflict).\par
- Most naming collisions occur in two cases:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 Two (or more) definitions for a function (or global variable) are introduced into separate files that are compiled into the same program. This will result in a linker error, as shown above.\par
{\pntext\f1\'B7\tab}Two (or more) definitions for a function (or global variable) are introduced into the same file (often via an #include). This will result in a compiler error.\b\par

\pard\sl240\slmult1\b0 - In C++, any name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly defined namespace called the global namespace (sometimes also called the global scope).\par
- When you use an identifier that is defined inside a namespace (such as the std namespace), you have to tell the compilerthat the identifier lives inside the namespace.\par
- The :: symbol is an operator called the scope resolution operator. The identifier to the left of the :: symbol identifies the namespace that the name to the right of the :: symbol is contained within. If no identifier to the left of the :: symbol is provided, the global namespace is assumed.\par
- Another way to access identifiers inside a namespace is to use a using directive statement. eg. using namespace std\line - A using directive allows us to access the names in a namespace without using a namespace prefix.\par
-Avoid using-directives (such as using namespace std;) at the top of your program or in header files. They violate the reason why namespaces were added in the first place.\par
\b\par

\pard\sl240\slmult1\qc\par
2.10 Introduction to the preprocessor\par
\par

\pard\sl240\slmult1\b0 - Prior to compilation, the code file goes through a phase known as translation.\par
- A code file with translations applied to it is called a translation unit.\par
- The most noteworthy of the translation phases involves the preprocessor. The preprocessor is best thought of as a separate program that manipulates the text in each code file.\par
- Preprocessor directives (often just called directives) are instructions that start with a # symbol and end with a newline (NOT a semicolon). \par
- These directives tell the preprocessor to perform specific particular text manipulation tasks. Note that the preprocessor does not understand C++ syntax -- instead, the directives have their own syntax\par
- When you #include a file, the preprocessor replaces the #include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.\par
- The #define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text. There are two basic types of macros: object-like macros, and function-like macros.\par
- Object-like macros can be defined in one of two ways: #define identifier or #define identifier substitution_text. When the preprocessor encounters this directive, any further occurrence of the identifier is replaced by substitution_text. \par
- Conditional compilation processor directives: #ifdef, #ifndef, and #endif.\par
- The #ifdef preprocessor directive allows the preprocessor to check whether an identifier has been previously #defined. If so, the code between the #ifdef and matching #endif is compiled. If not, the code is ignored. #ifndef is the opposite of #ifdef, in that it allows you to check whether an identifier has NOT been #defined yet.\par
- #if 0:  exclude a block of code from being compiled (as if it were inside a comment block). Use #endif to close #if 0\par
- In actuality, the output of the preprocessor contains no directives at all -- they are all resolved/stripped out before compilation, because the compiler wouldn\rquote t know what to do with them.\par
- Directives defined in one code file do not have impact on other code files in the same project.\par
\b\par

\pard\sl240\slmult1\qc 2.11 Header files\par

\pard\sl240\slmult1\par
\b0 - Header files usually have a .h extension, but you will occasionally see them with a .hpp extension or no extension at all. \par
- The primary purpose of a header file is to propagate declarations to code files.\par
- Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs.\par
- When you #include a file, the content of the included file is inserted at the point of inclusion. This provides a useful way to pull in declarations from another file.\par
- When it comes to functions and variables, it\rquote s worth keeping in mind that header files typically only contain function and variable declarations, not function and variable definitions (otherwise a violation of the one definition rule could result)\par
- Let\rquote s write a header file to relieve us of this burden. Writing a header file is surprisingly easy, as header files only consist of two parts:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 A header guard\par
{\pntext\f1\'B7\tab}The actual content of the header file, which should be the forward declarations for all of the identifiers we want other files to be able to see.\par

\pard\sl240\slmult1 - Use a .h suffix when naming your header files.\par
- If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).\par
- eg. #include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.\par
- Source files should #include their paired header file (if one exists).\par
- When we use angled brackets, we\rquote re telling the preprocessor that this is a header file we didn\rquote t write ourselves.\par
- Many of the libraries inherited from C that are still useful in C++ were given a c prefix (e.g. stdlib.h became cstdlib).\par
- When your code file #includes the first header file, you\rquote ll also get any other header files that the first header file includes (and any header files those include, and so on). These additional header files are sometimes called transitive includes, as they\rquote re included implicitly rather than explicitly.\par
- Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.\par
- To maximize the chance that missing includes will be flagged by compiler, order your #includes as follows:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 The paired header file\par
{\pntext\f1\'B7\tab}Other headers from your project\par
{\pntext\f1\'B7\tab}3rd party library headers\par
{\pntext\f1\'B7\tab}Standard library headers\par

\pard\sl240\slmult1 The headers for each grouping should be sorted alphabetically.\par
\b\par

\pard\sl240\slmult1\qc 2.12 Header guards\par
\par

\pard\sl240\slmult1\b0 - Header guard (also called an include guard) are conditional compilation directives that take the following form:\par

\pard\li720\sl240\slmult1 #ifndef SOME_UNIQUE_NAME_HERE\par
#define SOME_UNIQUE_NAME_HERE\par
// your declarations (and certain types of definitions) here\par
#endif\par

\pard\sl240\slmult1 - All of your header files should have header guards on them. SOME_UNIQUE_NAME_HERE can be any name you want, but by convention is set to the full filename of the header file, typed in all caps, using underscores for spaces or punctuation. Eg. \tab #ifndef SQUARE_H\par
\tab #define SQUARE_H\par
- Because of this possibility for guard name conflicts, many developers recommend using a more complex/unique name in your header guards. Some good suggestions are a naming convention of <PROJECT>_<PATH>_<FILE>_H , <FILE>_<LARGE RANDOM NUMBER>_H, or <FILE>_<CREATION DATE>_H\par
- #pragma once serves the same purpose as header guards, and has the added benefit of being shorter and less error-prone. For most projects, #pragma once works fine, and many developers prefer to use them over header guards. However, #pragma once is not an official part of the C++ language (and probably will never be, because it can\rquote t be implemented in a way that works reliably in all cases).\par
\b\par

\pard\sl240\slmult1\qc 2.13 How to design your first programs\line\par

\pard\sl240\slmult1\b0 - The most important thing to remember (and hardest thing to do) is to design your program before you start coding. \par
- Design step 1: Define your goal\par
- Design step 2: Define requirements/constraints\par
- Design step 3: Define your tools, targets, and backup plan\par
- Design step 4: Break hard problems down into easy problems\par
- Design step 5: Figure out the sequence of events\par
- Implementation step 1: Outlining your main function\par
- Implementation step 2: Implement each function\par
- Implementation step 3: Final testing\par
- Keep your programs simple to start\par
- Add features over time.\par
- Focus on one area at a time.\par
- Test each piece of code as you go.\par
- Don\rquote t invest in perfecting early code. \par
\par
}
 